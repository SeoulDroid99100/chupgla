from shivu import shivuu, xy
from pyrogram import filters, errors
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton
from datetime import datetime, timedelta
import random
import logging
from pyrogram import enums

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

TRAINING_COOLDOWN = 300  # 5 minutes in seconds

# Difficulty Settings (Corrected Symbols)
DIFFICULTY_SETTINGS = {
    "peaceful": {"range": (1, 3), "success_rate": 1.0, "label": "‚òò ·¥ò·¥á·¥Ä·¥Ñ·¥á“ì·¥ú ü"},  # 100% 1-3
    "easy": {"range": (3, 6), "success_rate": 0.8, "label": "‚ò° ·¥á·¥Äs è"},      # 80% 3-6
    "hard": {"range": (6, 10), "success_rate": 0.5, "label": "‚èö  ú·¥Ä Ä·¥Ö"},     # 50% 6-10
    "hardcore": {"range": (10, 20), "success_rate": 0.1, "label": "‚ò†  ú·¥Ä Ä·¥Ö·¥Ñ·¥è Ä·¥á"}, # 10% 10-20
}

# New ASCII Art
ASCII_ART = (
    "```\n"
    "‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚†§‚†§‚†§‚†§‚†§‚†§‚†§‚†§‚†§‚†§‚¢§‚£§‚£Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä\n"
    "‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°º‚†ã‚†Ä‚£Ä‚†Ñ‚°Ç‚†ç‚£Ä‚£í‚£í‚†Ç‚†Ä‚†¨‚†§‚†§‚†¨‚†ç‚†â‚†ù‚†≤‚£Ñ‚°Ä‚†Ä‚†Ä\n"
    "‚†Ä‚†Ä‚†Ä‚¢Ä‚°æ‚†Å‚†Ä‚†ä‚¢î‚†ï‚†à‚£Ä‚£Ä‚°Ä‚†à‚†Ü‚†Ä‚†Ä‚†Ä‚°ç‚†Å‚†Ä‚†Å‚¢Ç‚†Ä‚†à‚£∑‚†Ä‚†Ä\n"
    "‚†Ä‚†Ä‚£†‚£æ‚†•‚†Ä‚†Ä‚£†‚¢†‚£û‚£ø‚£ø‚£ø‚£â‚†≥‚£Ñ‚†Ä‚†Ä‚£Ä‚£§‚£∂‚£∂‚£∂‚°Ñ‚†Ä‚†Ä‚£ò‚¢¶‚°Ä\n"
    "‚¢Ä‚°û‚°ç‚£†‚†û‚¢ã‚°õ‚†∂‚†§‚£§‚†¥‚†ö‚†Ä‚†à‚†ô‚†Å‚†Ä‚†Ä‚¢π‚°è‚†Å‚†Ä‚£Ä‚£†‚†§‚¢§‚°ï‚†±‚£∑\n"
    "‚†ò‚°á‚†á‚£Ø‚†§‚¢æ‚°ô‚†≤‚¢§‚£Ä‚°Ä‚†§‚†Ä‚¢≤‚°ñ‚£Ç‚£Ä‚†Ä‚†Ä‚¢ô‚£∂‚£Ñ‚†à‚†â‚£∏‚°Ñ‚††‚£†‚°ø\n"
    "‚†Ä‚†π‚£ú‚°™‚†Ä‚†à‚¢∑‚£¶‚£¨‚£è‚†â‚†õ‚†≤‚£Æ‚£ß‚£Å‚£Ä‚£Ä‚†∂‚†û‚¢Å‚£Ä‚£®‚¢∂‚¢ø‚£ß‚†â‚°º‚†Å\n"
    "‚†Ä‚†Ä‚†à‚¢∑‚°Ä‚†Ä‚†Ä‚†≥‚£å‚°ü‚†ª‚†∑‚£∂‚£ß‚£Ä‚£Ä‚£π‚£â‚£â‚£ø‚£â‚£â‚£á‚£º‚£æ‚£ø‚†Ä‚°á‚†Ä\n"
    "‚†Ä‚†Ä‚†Ä‚†à‚¢≥‚°Ñ‚†Ä‚†Ä‚†ò‚†≥‚£Ñ‚°Ä‚°º‚†à‚†â‚†õ‚°ø‚†ø‚†ø‚°ø‚†ø‚£ø‚¢ø‚£ø‚£ø‚°á‚†Ä‚°á‚†Ä\n"
    "‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚¢¶‚£ï‚††‚£í‚†å‚°ô‚†ì‚†∂‚†§‚£§‚£ß‚£Ä‚£∏‚£á‚£¥‚£ß‚†æ‚†æ‚†ã‚†Ä‚†Ä‚°á‚†Ä\n"
    "‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ô‚†∂‚£≠‚£í‚†©‚†ñ‚¢†‚£§‚†Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†î‚†Å‚°∞‚†Ä‚£ß‚†Ä\n"
    "‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†õ‚†≤‚¢§‚£Ä‚£Ä‚†â‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚†Ä‚£†‚†è‚†Ä\n"
    "‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚†â‚†õ‚†í‚†≤‚†∂‚†§‚†¥‚†í‚†ö‚†Å‚†Ä‚†Ä\n"
    "```\n"
)


# Helper function for small caps (using Unicode) + Bold
def small_caps_bold(text):
    """Converts text to small caps (using Unicode characters) and bolds it."""
    small_caps_map = {
        'A': '·¥Ä', 'B': ' ô', 'C': '·¥Ñ', 'D': '·¥Ö', 'E': '·¥á', 'F': '“ì', 'G': '…¢',
        'H': ' ú', 'I': '…™', 'J': '·¥ä', 'K': '·¥ã', 'L': ' ü', 'M': '·¥ç', 'N': '…¥',
        'O': '·¥è', 'P': '·¥ò', 'Q': '«´', 'R': ' Ä', 'S': 's', 'T': '·¥õ', 'U': '·¥ú',
        'V': '·¥†', 'W': '·¥°', 'X': 'x', 'Y': ' è', 'Z': '·¥¢',
        '0': '‚ÇÄ', '1': '‚ÇÅ', '2': '‚ÇÇ', '3': '‚ÇÉ', '4': '‚ÇÑ', '5': '‚ÇÖ', '6': '‚ÇÜ',
        '7': '‚Çá', '8': '‚Çà', '9': '‚Çâ',
    }
    bold_text = ''.join(small_caps_map.get(char.upper(), char) for char in text)
    return f"**{bold_text}**"  # Wrap in ** for bolding


async def calculate_growth(difficulty: str) -> int:
    """Calculates growth based on difficulty, with success/failure."""
    if difficulty not in DIFFICULTY_SETTINGS:
        raise ValueError(f"Invalid difficulty: {difficulty}")

    settings = DIFFICULTY_SETTINGS[difficulty]
    if random.random() < settings["success_rate"]:
        min_growth, max_growth = settings["range"]
        return random.randint(min_growth, max_growth)
    else:
        return 0  # Growth failure


async def get_ranking(user_id: int, current_size: float) -> tuple[int, int]:
    """Gets the user's global ranking and the total number of users."""
    try:
        # Count users with a larger lund_size
        larger_users_count = await xy.count_documents({"progression.lund_size": {"$gt": current_size}})

        # Calculate the rank (add 1 because ranks start at 1, not 0)
        rank = larger_users_count + 1

        # Get the total number of users
        total_users = await xy.count_documents({})

        return rank, total_users
    except Exception as e:
        logger.exception(f"Error in get_ranking: {e}")
        raise

async def calculate_percentage_smaller(user_id: int, current_size: float) -> float:
    """Calculates the percentage of users with a smaller lund_size."""
    try:
        # Count total users with lund_size (exclude users without progression data)
        total_users = await xy.count_documents({"progression.lund_size": {"$exists": True}})
        
        if total_users <= 1:
            return 100.0  # You're the only one or no users
        
        # Count users smaller than current size
        smaller_users_count = await xy.count_documents({"progression.lund_size": {"$lt": current_size}})
        
        # Calculate percentage (exclude self from total)
        percentage = (smaller_users_count / (total_users - 1)) * 100
        return round(percentage, 2)

    except Exception as e:
        logger.exception(f"Error in calculate_percentage_smaller: {e}")
        raise


@shivuu.on_message(filters.command(["ltrain", "train", "lgrow", "grow"]))
async def training_command(client: shivuu, message: Message):
    user_id = message.from_user.id

    try:
        user_data = await xy.find_one({"user_id": user_id})

        if not user_data:
            await message.reply(small_caps_bold("·¥ò Ä·¥è“ì…™ ü·¥á …¥·¥è·¥õ “ì·¥è·¥ú…¥·¥Ö! ·¥ús·¥á / üs·¥õ·¥Ä Ä·¥õ ·¥õ·¥è  ô·¥á…¢…™…¥."))
            return

        # --- Cooldown Check ---
        last_trained = user_data.get("progression", {}).get("last_trained")
        if last_trained:
            time_since_last_train = datetime.utcnow() - last_trained
            if time_since_last_train.total_seconds() < TRAINING_COOLDOWN:
                remaining_cooldown = timedelta(seconds=TRAINING_COOLDOWN) - time_since_last_train
                await message.reply(small_caps_bold(f"·¥õ Ä·¥Ä…™…¥…™…¥…¢ …™s ·¥è…¥ ·¥Ñ·¥è·¥è ü·¥Ö·¥è·¥°…¥. ·¥ò ü·¥á·¥Äs·¥á ·¥°·¥Ä…™·¥õ {remaining_cooldown}."))
                return

        # --- Difficulty Selection (Inline Keyboard) ---
        buttons = []
        for difficulty, settings in DIFFICULTY_SETTINGS.items():
            label = settings["label"]
            range_str = f"{settings['range'][0]}-{settings['range'][1]} ·¥Ñ·¥ç"
            success_str = f"{int(settings['success_rate'] * 100)}%"
            button_text = f"{label} ({range_str}, {success_str})"
            buttons.append(
                InlineKeyboardButton(small_caps_bold(button_text), callback_data=f"train_{difficulty}")
            )

        # Arrange buttons in a 2x2 grid
        keyboard = [buttons[:2], buttons[2:]]
        difficulty_keyboard = InlineKeyboardMarkup(keyboard)
        await message.reply(small_caps_bold("·¥Ñ ú·¥è·¥ès·¥á ·¥Ä ·¥õ Ä·¥Ä…™…¥…™…¥…¢ ·¥Ö…™“ì“ì…™·¥Ñ·¥ú ü·¥õ è:"), reply_markup=difficulty_keyboard)

    except errors.MessageNotModified:
        # Handle the case where the message is not modified (e.g., user clicks the same button)
        pass
    except Exception as e:
        logger.exception(f"Error in training_command: {e}")
        await message.reply(small_caps_bold("·¥Ä…¥ ·¥ú…¥·¥áx·¥ò·¥á·¥Ñ·¥õ·¥á·¥Ö ·¥á Ä Ä·¥è Ä ·¥è·¥Ñ·¥Ñ·¥ú Ä Ä·¥á·¥Ö."))



@shivuu.on_callback_query(filters.regex(r"^train_(peaceful|easy|hard|hardcore)$"))
async def training_callback(client: shivuu, callback_query):
    user_id = callback_query.from_user.id
    difficulty = callback_query.data.split("_")[1]  # Extract difficulty
    chat_id = callback_query.message.chat.id # Get the chat ID

    try:
        user_data = await xy.find_one({"user_id": user_id})
        if not user_data: # Re-check for user data
            await callback_query.answer(small_caps_bold("·¥ò Ä·¥è“ì…™ ü·¥á …¥·¥è·¥õ “ì·¥è·¥ú…¥·¥Ö! ·¥ús·¥á / üs·¥õ·¥Ä Ä·¥õ ·¥õ·¥è  ô·¥á…¢…™…¥."), show_alert=True)
            return

        # --- Cooldown Check (within callback) ---
        last_trained = user_data.get("progression", {}).get("last_trained")
        if last_trained:
            time_since_last_train = datetime.utcnow() - last_trained
            if time_since_last_train.total_seconds() < TRAINING_COOLDOWN:
                remaining_cooldown = timedelta(seconds=TRAINING_COOLDOWN) - time_since_last_train
                await callback_query.answer(small_caps_bold(f"·¥õ Ä·¥Ä…™…¥…™…¥…¢ …™s ·¥è…¥ ·¥Ñ·¥è·¥è ü·¥Ö·¥è·¥°…¥. ·¥ò ü·¥á·¥Äs·¥á ·¥°·¥Ä…™·¥õ {remaining_cooldown}."), show_alert=True)
                return

        # --- Perform Training ---
        try:
            growth = await calculate_growth(difficulty)
            if growth > 0:
                new_size = round(user_data["progression"]["lund_size"] + growth, 2)
                update_data = {
                    "$set": {
                        "progression.lund_size": new_size,
                        "progression.last_trained": datetime.utcnow(),
                    },
                }
                result_message = f"üóø **…¢ Ä·¥è·¥°·¥õ ú:** +**{growth}**·¥Ñ·¥ç üìà\n" # Indicate successful growth
            else:
                new_size = user_data["progression"]["lund_size"]  # No change in size
                update_data = {
                    "$set": {
                        "progression.last_trained": datetime.utcnow(),
                    }
                }
                result_message = "‚ùå **·¥õ Ä·¥Ä…™…¥…™…¥…¢ “ì·¥Ä…™ ü·¥á·¥Ö!** …¥·¥è …¢ Ä·¥è·¥°·¥õ ú ·¥õ ú…™s ·¥õ…™·¥ç·¥á. üôÅ\n"

            await xy.update_one({"user_id": user_id}, update_data)


        except Exception as e:
            logger.exception(f"Error during training update: {e}")
            await callback_query.answer(small_caps_bold("·¥Ä…¥ ·¥á Ä Ä·¥è Ä ·¥è·¥Ñ·¥Ñ·¥ú Ä Ä·¥á·¥Ö ·¥Ö·¥ú Ä…™…¥…¢ ·¥õ Ä·¥Ä…™…¥…™…¥…¢. ·¥ò ü·¥á·¥Äs·¥á ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥  ü·¥Ä·¥õ·¥á Ä."), show_alert=True)
            return

        # --- Get Ranking and Percentage ---
        try:
            rank, total_users = await get_ranking(user_id, new_size)
            percentage_smaller = await calculate_percentage_smaller(user_id, new_size)

            next_train_time = datetime.utcnow() + timedelta(seconds=TRAINING_COOLDOWN)
            next_train_str = next_train_time.strftime("%H ú %M·¥ç")  # Format as "Xh Ym"

        except Exception as e:
            logger.exception(f"Error during rank calculation: {e}")
            await callback_query.answer(small_caps_bold("·¥Ä…¥ ·¥á Ä Ä·¥è Ä ·¥è·¥Ñ·¥Ñ·¥ú Ä Ä·¥á·¥Ö ·¥° ú…™ ü·¥á “ì·¥á·¥õ·¥Ñ ú…™…¥…¢  Ä·¥Ä…¥·¥ã…™…¥…¢ …™…¥“ì·¥è Ä·¥ç·¥Ä·¥õ…™·¥è…¥."), show_alert=True)
            return

        # --- Build Response Message ---
        response = ASCII_ART #Put at first the ascii
        response += (
            
            "‚ï≠‚îÅ„Äîüçå„Äï‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ„Äîüçå„Äï  \n"
            "‚îÉ   üí¶ **·¥á·¥†·¥è ü·¥ú·¥õ…™·¥è…¥ ·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á!** üí¶      \n"
            "‚ï∞‚îÅ„Äîüçå„Äï‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ„Äîüçå„Äï\n\n"
            "üß¨ ** è·¥è·¥ú Ä  ü·¥á…¢·¥á…¥·¥Ö·¥Ä Ä è  ü·¥ú…¥·¥Ö  ú·¥Äs ·¥ú…¥ ü·¥è·¥Ñ·¥ã·¥á·¥Ö …™·¥õs ·¥ò·¥è·¥õ·¥á…¥·¥õ…™·¥Ä ü!**\n"
            f"{result_message}"
            f"üîπ **·¥Ñ·¥ú Ä Ä·¥á…¥·¥õ s…™·¥¢·¥á:** **{new_size}**·¥Ñ·¥ç üëπ\n"
            f"üèÜ **·¥õ·¥è·¥ò  Ä·¥Ä…¥·¥ã…™…¥…¢:** #**{rank}** üëë\n"
            f"‚è≥ **…¥·¥áx·¥õ ·¥á…¥ ú·¥Ä…¥·¥Ñ·¥á·¥ç·¥á…¥·¥õ …™…¥:** {next_train_str} ‚åõ\n\n"
            "‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ‚ãÜ‚ãÖ‚òÜ‚ãÖ‚ãÜ ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïÆ\n"
            f"  üîª ** è·¥è·¥ú ·¥Ä Ä·¥á  ô…™…¢…¢·¥á Ä ·¥õ ú·¥Ä…¥** **{percentage_smaller}%** **·¥è“ì ·¥ò ü·¥Ä è·¥á Äs** üîª\n"
            "‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ ‚ãÜ‚ãÖ‚òÜ‚ãÖ‚ãÜ ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ"
        )
        await callback_query.edit_message_text(response, parse_mode=enums.ParseMode.MARKDOWN)

    except errors.MessageNotModified:
        # Handle the case where the message content is the same
        await callback_query.answer("No changes to apply.")

    except Exception as e:
        logger.exception(f"Error in training_callback: {e}")
        await callback_query.answer(small_caps_bold("·¥Ä…¥ ·¥ú…¥·¥áx·¥ò·¥á·¥Ñ·¥õ·¥á·¥Ö ·¥á Ä Ä·¥è Ä ·¥è·¥Ñ·¥Ñ·¥ú Ä Ä·¥á·¥Ö."), show_alert=True)
